#!/usr/local/bin/python
#
# Copyright 2015 iXsystems, Inc.
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#####################################################################
import argparse
import platform
from sys import stderr
from subprocess import Popen, PIPE


def __pipeopen(command_list, do_print=False):
    """
    The magic sauce that runs the shell command specified by
    `command_list` and waits for it to finish and returns the returncode
    of the process, stdout and stderr in the following format:
    (retcode, stdout, stderr).
    If the (optional) do_print flag is set as true it will print
    the stdout and stderr streams appropriately.

    Example Usage:
    (myretcode, mystdout, mystderr) = __pipeopen(['/bin/echo', 'hello'])
    """
    proc = Popen(command_list, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=False)
    proc.wait()
    (results_stdout, results_stderr) = proc.communicate()
    retcode = proc.returncode
    if do_print:
        if retcode != 0:
            stderr.write(results_stderr)
        print results_stdout
    return (retcode, results_stdout, results_stderr)


def __rel_list():
    """
    Lists the releases we have so `__fetch_jails` can be ran
    in case they aren't downloaded yet.
    """
    (retcode, results_stdout, results_stderr) = __pipeopen(
        ['/usr/local/sbin/iocage', 'list', '-r'])
    _exists = args.release in results_stdout
    return _exists


def __list_jails(args):
    """
    Wraps `warden list` and `warden list -v` to `iocage list`
    and `iocage list --long` respectively.
    """
    if args._long_list:
        (retcode, results_stdout, results_stderr) = __pipeopen(
            ['/usr/local/sbin/iocage', 'list', '--long'], do_print=True)
    else:
        (retcode, results_stdout, results_stderr) = __pipeopen(
            ['/usr/local/sbin/iocage', 'list'], do_print=True)


def __fetch_jails():
    """
    Fetches the RELEASE that is supplied by ``--version MAJOR.MINOR-RELEASE`
    if it doesn't exist.
    """
    (retcode, results_stdout, results_stderr) = __pipeopen(
        ['/usr/local/sbin/iocage', 'fetch', 'release={0}'.format(args.release)])


def __create_jail(args):
    """
    This wraps `warden create` and translates the syntax to `iocage create`.
    """
    # iocage looks for 'MAJOR.MINOR-RELEASE' without the patch level, this strips the patch level
    _host_release = '-'.join(platform.release().split('-')[:2])
    if args.boot:
        args.boot = 'on'
    else:
        args.boot = 'off'

    # Check if the user supplied a RELEASE, otherwise assume hosts RELEASE
    if not args.release:
        args.release = _host_release

    # If iocage doesn't have the RELEASE already fetched, do so now
    if __rel_list() is False:
        print '  Fetching:', args.release
        __fetch_jails()

    print '  Creating jail, please wait...'
    (retcode, results_stdout, results_stderr) = __pipeopen(
        ['/usr/local/sbin/iocage', 'create',
            'tag={0}'.format(args.tag),
            'ip4_addr={0}'.format(args.ip4),
            'boot={0}'.format(args.boot),
            'release={0}'.format(args.release)])
    if retcode == 0:
        print '  Jail created!'
    else:
        print results_stdout
        stderr.write(results_stderr)


def __boot_jail_prop(args):
    """
    Take 2 arguments and supplies that to `iocage set` for the jail
    """
    print '  Toggling jail property boot on {0}'.format(args.jail)
    (retcode, results_stdout, results_stderr) = __pipeopen(
        ['/usr/local/sbin/iocage', 'get',
         'boot',
         '{0}'.format(args.jail)])
    if 'off' in results_stdout:
        (retcode, results_stdout, results_stderr) = __pipeopen(
            ['/usr/local/sbin/iocage', 'set',
             'boot=on',
             '{0}'.format(args.jail)])
        if retcode == 0:
            print '  Property boot set on {0}'.format(args.jail)
        else:
            print results_stdout
            stderr.write(results_stderr)
    else:
        (retcode, results_stdout, results_stderr) = __pipeopen(
            ['/usr/local/sbin/iocage', 'set',
                'boot=off',
                '{0}'.format(args.jail)])
        if retcode == 0:
            print '  Property boot unset on {0}'.format(args.jail)
        else:
            print results_stdout
            stderr.write(results_stderr)


def __warden_usage():
    """
    Lists what commands we support from `warden`.
    Not all subcommands of those are supported.
    """
    _supported_commands = ['auto', 'create', 'list']
    msg = "Supported Commands:\n"
    for i in _supported_commands:
        msg += "  {0}".format(i)
    return msg

# Set up the parser, default subparser and the subparsers
parser = argparse.ArgumentParser(
    description='Warden to iocage wrapper',
    usage=__warden_usage()
)
subparsers = parser.add_subparsers()

_auto_parser = subparsers.add_parser('auto')
_auto_parser.add_argument('jail', action='store')
_auto_parser.set_defaults(func=__boot_jail_prop)

_create_parser = subparsers.add_parser('create')
_create_parser.add_argument('tag', action='store')
_create_parser.add_argument('--ipv4', action='store', dest='ip4')
_create_parser.add_argument('--startauto', action='store_true', dest='boot')
_create_parser.add_argument('--version', action='store', dest='release')
_create_parser.set_defaults(func=__create_jail)

_list_parser = subparsers.add_parser('list')
_list_parser.add_argument('-v', help='Wraps "iocage list --long"',
                          action='store_true', dest='_long_list')
_list_parser.set_defaults(func=__list_jails)

args = parser.parse_args()
args.func(args)
